"""
.. module: InfraRed

Viper Infra Red Capture, Send and Decode module

This module contains class definitions and methods for capture, decode and send IR packets.
* The IRPacket class allow the definition of IRPacket objects.
* The IRReceiver class handle the capture of IR packet controlling the signal gathered from an IR receiver and demodulator connected to a board pin empowered with ICU feature
* The decode method allow extraction from raw acquired data of packet detailed information and analysis of the message protocol. The method returns an IRPacketobject.


"""



import icu
import pwm

class IRPacket():
    """
==================
IRPacket class
==================

.. class:: IRPacket(packet_type,addr1, addr2,d1,d2,hexd,rawdata,databits)

    This is the class that allows definition of IR messages/packets objects 
    * packet_type: is a string identifying the packet IR protocol of the message. Currently the following packets are supported: SAMSUNG, NEC and UNKNOWN.
    * addr1: is the first address data packet (to be set to 0 if not supported by the selected protocol)
    * addr2: is the second address data packet (to be set to 0 if not supported by the selected protocol)
    * d1: is the first message data packet
    * d2: is the second message data packet (to be set as 0 if not supported by the selected protocol)
    * hexd: is the Hexadecimal string representing  the data contained in d1 and d2
    * rawdata: is a touple containing the raw data acquired by the transducer during the acquisition of the packet. Data are listed as int representing the duration in microseconds of a "pulse state" the first reported time is an HIGH pulse duration, the second is the duration of the following LOW pulse.
    * DataBITs: is a string of 0 and 1 representing the boolean decode of rawdata obtained through the decoder selected according to the packet_type  

IrPacket are generated by the infrared.decode() and are taken as input by the IRSender.send() method.

    """   


    def __init__(self,packet_type,addr1, addr2,d1,d2,hexd,rawdata,databits):
        self.packetType=packet_type
        self.addres1=addr1
        self.addres2=addr2
        self.data1=d1
        self.data2=d2
        self.hexdata=hexd 
        self.raw=rawdata
        self.bits=databits
    
    """
.. method:: printPacket(stream)

    generates a Print-friendly and readable output containing the packet data and print it on the selected stream.
    
    """

    def printPacket(self,s):
        print("packetType:",self.packetType,stream=s)
        print("Address1:",self.addres1,stream=s)
        print("Address2:",self.addres2,stream=s)
        print("Data1:",self.data1,stream=s)
        print("Data2:",self.data2,stream=s)
        print("HEX:",self.hexdata,stream=s)
        print("RAW:",self.raw,stream=s)
        print("DataBITs:",self.bits,stream=s)
        print("-"*30)   

    
class IRReceiver():

    """
==================
IRReceiver class
==================

.. class:: IRReceiver(IrRecvPin)

    This is the class that allows definition of an IR receivers made by connecting and IR demodulator to the selected pin.
    The pin have to be endowed with ICU functionality

    """

    def __init__(self,IrRecvPin):
        self.pin = IrRecvPin


    def to_samsung_times(self,x):
            res, times = [], [590,1690,4500]
            for i in x:
                for t in times:
                    if abs(i-t) < 200:
                        res.append(t)
                        break
            return res

    def to_nec_times(self,x):
        res, times = [], [560,1690,4500,9000]
        for i in x:
            for t in times:
                if abs(i-t) < 200:
                    res.append(t)
                    break
        return res


    def decodeSamsung(self,data):
        result=[]
        data1=0
        data2=0
        databits=[]
        x= self.to_samsung_times(data)
        for i in range(2,32,2):            
            if x[i]==590:  #ok this is the start of a bit
                if x[i+1]==590:  #this is a ZERO 
                    databits.append("0")
                    data1=data1
                elif x[i+1]==1690: #this is a ONE                
                    databits.append("1")
                    data1=data1+1
            data1=2*data1    
            
        for i in range(34,64,2):            
            if x[i]==590:  #ok this is the start of a bit
                if x[i+1]==590:  #this is a ZERO
                    databits.append("0")
                    data2=data2
                elif x[i+1]==1690: #this is a ONE
                    databits.append("1")
                    data2=data2+1
            data2=2*data2        

        
        if x[66]==590:
            databits.append("1")
            data2=data2+1
        HEX=hex(data1,prefix="")+hex(data2,prefix="")
        
        return IRPacket("Samsung",0,0,data1,data2,HEX,x,databits)

    def decodeNec(self,data):
        result=[]
        addres1=0
        addres2=0
        data1=0
        data2=0
        databits=[]
        x= self.to_nec_times(data)
        for i in range(2,32,2):            
            if x[i]==560:  #ok this is the start of a bit
                if x[i+1]==560:  #this is a ZERO                
                    databits.append("0")
                    data1=data1
                elif x[i+1]==1690: #this is a ONE
                    databits.append("1")
                    data1=data1+1
            data1=2*data1

        
        for i in range(34,64,2):            
            if x[i]==560:  #ok this is the start of a bit
                if x[i+1]==1690:  #this is a ZERO
                    databits.append("0")
                    data2=data2
                elif x[i+1]==1690: #this is a ONE
                    databits.append("1")
                    data2=data2+1
            data2=2*data2        

        
        if x[66]==560:
            databits.append("1")
            data2=data2+1
        HEX=hex(data1,prefix="")+hex(data2,prefix="")
        
        return IRPacket("NEC",0,0,data1,data2,HEX,x,databits)

    """
    .. method:: decode(data)

        Analyze the raw captured data identifying the protocol.
        If the protocol is recognized data are decoded and an IRPacket returned.
        Otherwise an IRPacket with packet_type "UNKNOWN" is returned
    """
       

    def decode(self,x): 

        
        if len(x)>66 and abs(4500-x[0])<200 and abs(4500-x[1])<200 :  #ok we have a Samsung data packet
            packet=self.decodeSamsung(x)
        
        elif len(x)>52 and abs(9000-x[0])<200 and abs(4500-x[1])<200 :  #ok we have a NEC data packet
            packet=self.decodeNec(x)
        else:
            
            packet=IRPacket("Unknown",0,0,0,0,"000000",x,[])
        return packet    
               



   
    """
    .. method:: capture(max_samples=100,time_window=200,wait=0)

    Start the IR capture activating the ICU on the receiver pin.
    * max_samples set the number of samples to be collected before terminate the capture. Default is set to 100 that works for most of the used IR protocols.
    * time_window set the max amount in milliseconds of the capture window. Default is set to 200 milliseconds that works for most of the used IR protocols. 
    * wait allows defining a sleeping time in millisecond to be waited after a capture in order to avoid capturing repeated packet as partial raw data.
    Consider that air Conditioning remote controller IR packets are very long therefore play with these values for optimizing the capture according to the designed application.  
    
    The method returns raw captured data packed that can be used as input of IRSender.sendRaw() or decoded by using IRReceiver.decode()
    """
    def capture(self,max_samples=100,time_window=200,wait=0):
        x=icu.capture(self.pin,LOW,max_samples,time_window,pull=HIGH)
        if wait!=0:
            sleep(wait)
        return x

    
    """
    .. method:: captureAndDecode(max_samples=100,time_window=200,wait=0)

    Start the IR capture activating the ICU on the receiver pin and pass the captured raw signal to the decode method returning an IRPacket
    * max_samples set the number of samples to be collected before terminate the capture. Default is set to 100 that works for most of the used IR protocols.
    * time_window set the max amount in milliseconds of the capture window. Default is set to 200 milliseconds that works for most of the used IR protocols. 
    * wait allows to define a sleeping time in millisecond to be waited after a capture in order to avoid capturing repeated packet as partial raw data.
 
    Consider that air Conditioning remote controller IR packets are very long therefore play with these values for optimizing the capture according to the designed application.  
    
    The method returns an IRPacket.
   
    """
    def captureAndDecode(self,max_samples=100,time_window=200,wait=0):
        x=icu.capture(self.pin,LOW,max_samples,time_window,pull=HIGH)
        if wait!=0:
            sleep(wait)
        return self.decode(x)
      
    
    """
    ==================
    IRSender class
    ==================

    .. class:: IRSender(IRSenderPin,Frequency=36000,Duty=30)

    This is the class that allows definition of an IR sender made by connecting and IR LED to a pin endowed with PWM.
    * IRSenderPin: it is the pin where the LED is connected. Have to be passed to the method specifying the PWM feature e.i: D3.PWM
    * Frequency: it is the IR pulse modulation frequency. default is set to 36KHz that is the most used standard.
    * Duty: It is the duration in percentage 0-100 of the IR pulse. The duty definition allow to reduce power consumption avoiding long pulses. Default is set to 30 while values in the range 20-50 can be used. 

    The class has two methods for sending respectively raw data and IRPacket.
    """


class IRSender():
    def __init__(self,IRSenderPin,Frequency=36000,Duty=30):
        self.period=1000000//Frequency
        self.duty=self.period*Duty//100
        self.senderPin=IRSenderPin

    """
    .. method:: sendRaw(data)

    Send raw data by taking as input a list of pulses duration in microseconds. The first represents the duration of IR firing phase (state 1) while the the second is the IR LED  OFF phase (state 0)...
   
    """
    
            
    def sendRaw(self,x):
        state = 1
        for pulse in x: 
            npulse=pulse//self.period
            #print("npulse",npulse)
            if state:
                pwm.write(self.senderPin,self.period,self.duty,MICROS,npulse)
            else:
                pwm.write(self.senderPin,self.period,0,MICROS)
                sleep(pulse,MICROS)  #to be changed with new pwm strategy
            state = state^1


    """
    .. method:: send(IRPacket)

    Send the IR message contained in the passed IRPacket. If IRPacket packet_type is UNKNOWN data are sent as raw data.
   
    """        
            
    def send(self,x):
        self.sendRaw(x.raw)